// lib/features/export/domain/services/pdf_service.dart

import 'dart:io';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:intl/intl.dart';
import '../../../camera/domain/models/measurement.dart';
import '../../../results/data/repositories/measurement_repository.dart';

class PDFService {
  final MeasurementRepository _repository = MeasurementRepository();
  final String _currentDateTime = '2025-02-05 19:25:32';
  final String _username = 'surajgore-007';

  Future<File> generateAndSavePDF() async {
    try {
      await _repository.initialize();
      final measurements = await _repository.getAllMeasurements();

      if (measurements.isEmpty) {
        throw Exception('No measurements available to export');
      }

      final pdf = pw.Document();

      pdf.addPage(
        pw.MultiPage(
          pageFormat: PdfPageFormat.a4,
          margin: const pw.EdgeInsets.all(32),
          header: (context) =>
              _buildPageHeader(context.pageNumber, context.pagesCount),
          footer: (context) =>
              _buildPageFooter(context.pageNumber, context.pagesCount),
          build: (context) => [
            _buildHeader(),
            pw.SizedBox(height: 20),
            _buildSummary(measurements),
            pw.SizedBox(height: 20),
            _buildMeasurementsTable(measurements),
            pw.SizedBox(height: 20),
            ...measurements
                .expand((m) => [
                      _buildMeasurementDetail(m),
                      pw.SizedBox(height: 20),
                      if (measurements.last != m) pw.Divider(thickness: 2),
                      if (measurements.last != m) pw.SizedBox(height: 20),
                    ])
                .toList(),
          ],
        ),
      );

      return await _savePDF(pdf);
    } catch (e) {
      print('Error generating PDF: $e');
      rethrow;
    }
  }

  pw.Widget _buildPageHeader(int pageNumber, int totalPages) {
    return pw.Container(
      decoration: pw.BoxDecoration(
        border:
            pw.Border(bottom: pw.BorderSide(width: 0.5, color: PdfColors.grey)),
      ),
      margin: const pw.EdgeInsets.only(bottom: 20),
      padding: const pw.EdgeInsets.only(bottom: 8),
      child: pw.Row(
        mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
        children: [
          pw.Text(
            'AI Measure Report',
            style: pw.TextStyle(
              fontSize: 12,
              fontWeight: pw.FontWeight.bold,
            ),
          ),
          pw.Text(
            'Page $pageNumber of $totalPages',
            style: const pw.TextStyle(fontSize: 12),
          ),
        ],
      ),
    );
  }

  pw.Widget _buildPageFooter(int pageNumber, int totalPages) {
    return pw.Container(
      decoration: pw.BoxDecoration(
        border:
            pw.Border(top: pw.BorderSide(width: 0.5, color: PdfColors.grey)),
      ),
      margin: const pw.EdgeInsets.only(top: 20),
      padding: const pw.EdgeInsets.only(top: 8),
      child: pw.Row(
        mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
        children: [
          pw.Text(
            'Generated on: $_currentDateTime',
            style: const pw.TextStyle(fontSize: 10),
          ),
          pw.Text(
            'Generated by: $_username',
            style: const pw.TextStyle(fontSize: 10),
          ),
        ],
      ),
    );
  }

  pw.Widget _buildHeader() {
    return pw.Header(
      level: 0,
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          pw.Text(
            'AI Measure - Measurement Report',
            style: pw.TextStyle(
              fontSize: 24,
              fontWeight: pw.FontWeight.bold,
              color: PdfColors.blue800,
            ),
          ),
          pw.SizedBox(height: 8),
          pw.Text(
            'Generated on: $_currentDateTime',
            style: const pw.TextStyle(fontSize: 14),
          ),
          pw.Text(
            'Generated by: $_username',
            style: const pw.TextStyle(fontSize: 14),
          ),
        ],
      ),
    );
  }

  pw.Widget _buildSummary(List<SavedMeasurement> measurements) {
    final totalMeasurements = measurements.length;
    final uniqueTypes =
        measurements.map((m) => m.measurement.objectType).toSet().length;
    final averageConfidence =
        measurements.fold(0.0, (sum, m) => sum + m.measurement.confidence) /
            totalMeasurements;

    return pw.Container(
      padding: const pw.EdgeInsets.all(10),
      decoration: pw.BoxDecoration(
        color: PdfColors.grey100,
        borderRadius: const pw.BorderRadius.all(pw.Radius.circular(8)),
      ),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          pw.Text(
            'Summary',
            style: pw.TextStyle(
              fontSize: 16,
              fontWeight: pw.FontWeight.bold,
            ),
          ),
          pw.SizedBox(height: 8),
          pw.Text('Total Measurements: $totalMeasurements'),
          pw.Text('Unique Object Types: $uniqueTypes'),
          pw.Text(
              'Average Confidence: ${(averageConfidence * 100).toStringAsFixed(1)}%'),
        ],
      ),
    );
  }

  pw.Widget _buildMeasurementsTable(List<SavedMeasurement> measurements) {
    return pw.Table(
      border: pw.TableBorder.all(width: 0.5),
      children: [
        // Header
        pw.TableRow(
          decoration: pw.BoxDecoration(
            color: PdfColors.grey300,
          ),
          children: [
            _buildTableCell('Object Type', isHeader: true),
            _buildTableCell('Width (cm)', isHeader: true),
            _buildTableCell('Height (cm)', isHeader: true),
            _buildTableCell('Depth (cm)', isHeader: true),
            _buildTableCell('Confidence', isHeader: true),
            _buildTableCell('Date', isHeader: true),
          ],
        ),
        // Data rows
        ...measurements.map((m) => pw.TableRow(
              children: [
                _buildTableCell(m.measurement.objectType),
                _buildTableCell(m.measurement.width.toStringAsFixed(2)),
                _buildTableCell(m.measurement.height.toStringAsFixed(2)),
                _buildTableCell(m.measurement.depth.toStringAsFixed(2)),
                _buildTableCell(
                    '${(m.measurement.confidence * 100).toStringAsFixed(1)}%'),
                _buildTableCell(DateFormat('yyyy-MM-dd HH:mm')
                    .format(m.measurement.timestamp)),
              ],
            )),
      ],
    );
  }

  pw.Widget _buildTableCell(String text, {bool isHeader = false}) {
    return pw.Padding(
      padding: const pw.EdgeInsets.all(8),
      child: pw.Text(
        text,
        style: pw.TextStyle(
          fontSize: 10,
          fontWeight: isHeader ? pw.FontWeight.bold : null,
        ),
        textAlign: pw.TextAlign.center,
      ),
    );
  }

  pw.Widget _buildMeasurementDetail(SavedMeasurement measurement) {
    return pw.Container(
      padding: const pw.EdgeInsets.all(10),
      decoration: pw.BoxDecoration(
        border: pw.Border.all(width: 0.5, color: PdfColors.grey300),
        borderRadius: const pw.BorderRadius.all(pw.Radius.circular(8)),
      ),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          pw.Text(
            'Measurement Details - ${measurement.measurement.objectType}',
            style: pw.TextStyle(
              fontSize: 18,
              fontWeight: pw.FontWeight.bold,
              color: PdfColors.blue800,
            ),
          ),
          pw.SizedBox(height: 10),
          pw.Row(
            crossAxisAlignment: pw.CrossAxisAlignment.start,
            children: [
              pw.Expanded(
                flex: 2,
                child: _buildMeasurementInfo(measurement.measurement),
              ),
              pw.SizedBox(width: 20),
              pw.Expanded(
                flex: 3,
                child: _buildMeasurementImage(measurement.imagePath),
              ),
            ],
          ),
        ],
      ),
    );
  }

  pw.Widget _buildMeasurementInfo(Measurement measurement) {
    return pw.Column(
      crossAxisAlignment: pw.CrossAxisAlignment.start,
      children: [
        _buildInfoRow('Object Type:', measurement.objectType),
        _buildInfoRow('Width:', '${measurement.width.toStringAsFixed(2)} cm'),
        _buildInfoRow('Height:', '${measurement.height.toStringAsFixed(2)} cm'),
        _buildInfoRow('Depth:', '${measurement.depth.toStringAsFixed(2)} cm'),
        _buildInfoRow('Confidence:',
            '${(measurement.confidence * 100).toStringAsFixed(1)}%'),
        _buildInfoRow('Date:',
            DateFormat('yyyy-MM-dd HH:mm').format(measurement.timestamp)),
      ],
    );
  }

  pw.Widget _buildInfoRow(String label, String value) {
    return pw.Padding(
      padding: const pw.EdgeInsets.symmetric(vertical: 4),
      child: pw.Row(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          pw.Text(
            label,
            style: pw.TextStyle(fontWeight: pw.FontWeight.bold),
          ),
          pw.SizedBox(width: 8),
          pw.Expanded(
            child: pw.Text(
              value,
              style: const pw.TextStyle(fontSize: 12),
            ),
          ),
        ],
      ),
    );
  }

  pw.Widget _buildMeasurementImage(String imagePath) {
    try {
      final image = pw.MemoryImage(
        File(imagePath).readAsBytesSync(),
      );
      return pw.Container(
        height: 200,
        decoration: pw.BoxDecoration(
          border: pw.Border.all(width: 0.5, color: PdfColors.grey300),
          borderRadius: const pw.BorderRadius.all(pw.Radius.circular(4)),
        ),
        child: pw.ClipRRect(
          horizontalRadius: 4,
          verticalRadius: 4,
          child: pw.Center(
            child: pw.Image(image, fit: pw.BoxFit.contain),
          ),
        ),
      );
    } catch (e) {
      return pw.Container(
        height: 200,
        decoration: pw.BoxDecoration(
          border: pw.Border.all(width: 0.5, color: PdfColors.grey300),
          borderRadius: const pw.BorderRadius.all(pw.Radius.circular(4)),
        ),
        child: pw.Center(
          child: pw.Column(
            mainAxisAlignment: pw.MainAxisAlignment.center,
            children: [
              pw.Icon(const pw.IconData(0xe3ab)), // broken image icon
              pw.SizedBox(height: 8),
              pw.Text('Image not available'),
            ],
          ),
        ),
      );
    }
  }

  Future<File> _savePDF(pw.Document pdf) async {
    try {
      final output = await getTemporaryDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final file = File('${output.path}/measurements_$timestamp.pdf');
      await file.writeAsBytes(await pdf.save());
      return file;
    } catch (e) {
      print('Error saving PDF: $e');
      rethrow;
    }
  }

  Future<void> sharePDF(File file) async {
    try {
      await Share.shareFiles(
        [file.path],
        text: 'AI Measure - Measurement Report',
      );
    } catch (e) {
      print('Error sharing PDF: $e');
      rethrow;
    }
  }
}
